<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

        var config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 600,
            physics: {
                default: 'arcade',
            },

            scene: {
                preload: preload,
                create: create,
                update: update,
            }

        };

        var game = new Phaser.Game(config);

        //Game Objects
        var platforms;
        var map;
        var player;
        var mark;
        var seacreatures = [];

        //Keyboard controls
        var cursors;
        var keys;
        var space;

        var jump_number;
        var graphics;

        var gun_type = "machine";
        var shoot_cool_down = true;
        var shooting_state = false;

        function preload() {
            this.load.image('sky', 'assets/deepblue.png');
            this.load.image('platform', 'assets/platform.png');
            this.load.image('missile', 'assets/missile.png');
            this.load.image('mark', 'assets/mark.png');
            this.load.atlas('slime', 'assets/slimesheet.png', 'assets/slimesheet.json');
            this.load.atlas('seacreatures', 'assets/seacreatures_json.png', 'assets/seacreatures_json.json');

            this.load.tilemapTiledJSON('tilemap', 'assets/funny.json');
            this.load.image('tilesheet1', 'assets/tileset_x1.png');
        }

        function create() {
            //Hello World
            // const map = this.make.tilemap({key:'tilemap', tileWidth: 50, tileHeight: 50 });
            // tileset = map.addTilesetImage('tilesheet1');
            // layer = map.createLayer('Tile Layer 1', tileset);

            // zoom
            this.cameras.main.setZoom(1);

            //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
            let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);

            //create all animations
            this.anims.create({ key: 'jellyfish', frames: this.anims.generateFrameNames('seacreatures', { prefix: 'blueJellyfish', end: 32, zeroPad: 4 }), repeat: -1 });
            this.anims.create({ key: 'greenjellyfish', frames: this.anims.generateFrameNames('seacreatures', { prefix: 'greenJellyfish', end: 39, zeroPad: 4 }), repeat: -1 });
            this.anims.create({ key: 'octopus', frames: this.anims.generateFrameNames('seacreatures', { prefix: 'octopus', end: 24, zeroPad: 4 }), repeat: -1 });

            let playerAnimations = {};
            var idle = this.anims.create({ key: 'slime_idle', frames: this.anims.generateFrameNames('slime', { prefix: 'slime_idle', end: 5, zeroPad: 2 }), repeat: -1, frameRate: 10 });
            playerAnimations['idle'] = idle;
            var left = this.anims.create({ key: 'slime_left', frames: this.anims.generateFrameNames('slime', { prefix: 'slime_left', end: 5, zeroPad: 2 }), repeat: -1, frameRate: 10 });
            playerAnimations['left'] = left;
            var right = this.anims.create({ key: 'slime_right', frames: this.anims.generateFrameNames('slime', { prefix: 'slime_right', end: 5, zeroPad: 2 }), repeat: -1, frameRate: 10 });
            playerAnimations['right'] = right;

            //Create the platforms and the player character set to collide with the platforms
            createPlatforms(this);

            // entities
            mark = new Mark(this, 0, 0, 'mark');

            player = new Player(this, 400, 400, 'slime', playerAnimations);
            this.physics.add.collider(player, platforms);
            player.play(player.animations['idle']);

            //will be updated with new sprites
            let jellyfish = new SeaCreature(this, 200, 150, 'seacreatures', 'jellyfish');
            jellyfish.addTween(this, jellyfish.x, jellyfish.y + 20, 2000);
            seacreatures.push(jellyfish);
            //making my mark
            let greenjellyfish = new SeaCreature(this, 200, 150, 'seacreatures', 'greenjellyfish');
            greenjellyfish.addTween(this, greenjellyfish.x - 20, greenjellyfish.y + 300, 2000);
            seacreatures.push(greenjellyfish);

            let octopus = new SeaCreature(this, 700, 300, 'seacreatures', 'octopus');
            octopus.addTween(this, octopus.x + 400, octopus.y, 2000);
            seacreatures.push(octopus);

            //Set up user input
            cursors = this.input.keyboard.createCursorKeys();
            keys = this.input.keyboard.addKeys('A, D, W, S, Q');


            this.input.on('pointermove', function (pointer) {
                mark.x = pointer.worldX;
                mark.y = pointer.worldY;
            }, this);

            this.input.on('pointerdown', function (pointer) {
                if(gun_type === "machine")
                    shooting_state = true;
                else if(gun_type === "shotgun")
                {
                    angle = Phaser.Math.Angle.Between(player.x, player.y, mark.x, mark.y);
                    var bullet;
                    bullet = new Bullet(this, player.x, player.y, 'missile', angle);
                    bullet = new Bullet(this, player.x, player.y, 'missile', angle + 15/180*Math.PI);
                    bullet = new Bullet(this, player.x, player.y, 'missile', angle - 15/180*Math.PI);
                    shoot_cool_down = false;
                    this.time.delayedCall(1000, cool_down, [], this);
                    this.physics.add.overlap(bullet, seacreatures, bullet_hit, null, this);
                    this.physics.add.overlap(bullet, platforms, bullet_hit_wall, null, this);
                    this.physics.add.collider(bullet, platforms);
                }
            }, this);

            this.input.on('pointerup', function (pointer) {
                console.log("up");
                shooting_state = false;
            }, this);



            graphics = this.add.graphics();
        }

        function createPlatforms(scene) {
            platforms = scene.physics.add.staticGroup();

            //basePlatform is the floor of the game
            let basePlatform = platforms.create(game.scale.width / 2, game.scale.height - 30, 'platform');
            basePlatform.setScale(3, 1).refreshBody();

            platforms.create(250, 250, 'platform');
            platforms.create(950, 400, 'platform');
        }

        function update() {
            //Player will not move in the x-axis unless a movement key is being pressed
            //player.setVelocityX(0);

            //Player has "drag" on the x-axis meaning they slide a bit after an input
            player.setDragX(1500);

            //Handle player movements
            var i = 0;
            if (cursors.left.isDown || keys.A.isDown) {
                i = 1
                player.setVelocityX(-200);
                player.play(player.animations['left'], true);
            }
            else if (cursors.right.isDown || keys.D.isDown) {
                i = 1
                player.setVelocityX(200);
                player.play(player.animations['right'], true);
            }

            if (keys.W.isDown) {
                i = 1
                player.setVelocityY(-200);
            }
            else if (keys.S.isDown) {
                i = 1
                player.setVelocityY(200);
            }

            if (i === 0) {
                player.setVelocityY(0);
                player.setVelocityX(0);
                player.play(player.animations['idle'], true);
            }

            if (keys.Q.isDown) {
                if (gun_type === "machine")
                    gun_type = "shotgun";
                else
                    gun_type = "machine";
            }

            this.cameras.main.centerOn(player.x, player.y);

            if (shooting_state) {
                if (shoot_cool_down && gun_type == "machine") {
                    angle = Phaser.Math.Angle.Between(player.x, player.y, mark.x, mark.y);
                    var bullet;
                    bullet = new Bullet(this, player.x, player.y, 'missile', angle);
                    shoot_cool_down = false;
                    this.time.delayedCall(100, cool_down, [], this);
                    this.physics.add.overlap(bullet, seacreatures, bullet_hit, null, this);
                    this.physics.add.overlap(bullet, platforms, bullet_hit_wall, null, this);
                    this.physics.add.collider(bullet, platforms);
                }
            }
        }

        function cool_down() {
            shoot_cool_down = true;
        }

        function jump(event) {
            if (jump_number > 0) {
                jump_number = jump_number - 1;
                player.setVelocityY(-700);
            }
        }

        class Bullet extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, spritesheet, angle) {
                super(scene, x, y, spritesheet);
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setAngle(angle * (180 / Math.PI) + 225);
                this.setScale(0.1);
                this.setVelocityX(700 * Math.cos(angle));
                this.setVelocityY(700 * Math.sin(angle));
            }
        }

        class Mark extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, spritesheet) {
                super(scene, x, y, spritesheet);
                scene.add.existing(this);
                this.setScale(0.7);
            }
        }

        function bullet_hit(obj1, obj2) {
            obj1.destroy();
            obj2.destroy();
        }

        function bullet_hit_wall(obj1, obj2) {
            obj1.destroy();
        }

        class Player extends Phaser.Physics.Arcade.Sprite {
            animations;
            constructor(scene, x, y, spritesheet, animations) {
                super(scene, x, y, spritesheet);
                this.animations = animations;
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setScale(2);
                this.setCollideWorldBounds(true);
            }
        }

        class SeaCreature extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, spritesheet, animation) {
                super(scene, x, y, spritesheet, animation);
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setScale(0.8);
                this.play(animation);
            }

            addTween(scene, xDist, yDist, time) {
                scene.tweens.add({ targets: this, x: xDist, y: yDist, duration: time, ease: 'Sine.easeInOut', repeat: -1, yoyo: true });
            }
        }

    </script>

</body>

</html>
